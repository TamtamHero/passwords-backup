{"version":3,"sources":["logo.svg","components/RestoreButton/index.js","components/BackupButton/index.js","components/AppExplanations/index.js","App.js","index.js","controller/PasswordsManager.js"],"names":["RestoreButton","text","color","disabled","hidden","onClick","useState","isLoading","setLoading","file","useRef","hasFileInputBeenCanceled","current","value","length","document","body","onfocus","onTriggerFileSelect","useCallback","click","onSelectedFileChanged","event","target","files","then","className","style","type","ref","onChange","accept","BackupButton","onTriggerRunThenSaveFile","fileData","blob","Blob","JSON","stringify","url","URL","createObjectURL","elem","createElement","href","download","appendChild","removeChild","downloadFile","AppExplanations","expandedItems","setexpandedItems","allowZeroExpanded","allowMultipleExpanded","update","newExpandedItemUUID","itemButtonBottom","getElementById","getBoundingClientRect","bottom","window","innerHeight","scrollBy","children","listen","log","console","App","ask_device","device_handler","request","Promise","resolve","a","result","connected","connect","setConnected","toast","info","autoClose","setBusy","dismiss","success","disconnect","error","toString","isBusy","isConnected","PasswordsManager","passwordsManager","hideProgressBar","src","logo","alt","dump_metadatas","metadatas","load_metadatas","packageJson","version","ReactDOM","render","StrictMode","this","allowedStatuses","busy","transport","TransportWebUSB","create","getAppInfo","appName","Error","getAppConfig","appConfig","storage_size","close","readUInt16BE","errors","json_metadatas","Buffer","alloc","parsed_metadatas","parse","offset","forEach","element","nickname","charsets","write","metadatas_list","erased_list","corruptions","len","erased","push","slice","chunk","is_last","send","from","isSuccess","mapProtocolError","_lock","app_name_length","app_name","app_version_length","app_version","_unlock","readUInt32BE","keyboard_type","press_enter_after_typing","concat","_toJSON","JSON_metadatas","_toBytes","i","_load_metadatas_chunk"],"mappings":"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","file":"static/js/main.1e031dfa.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.aeffe6a7.svg\";","import React, { useRef, useCallback, useState } from \"react\";\nimport './index.css';\n\nfunction RestoreButton({ text, color, disabled, hidden, onClick }) {\n    const [isLoading, setLoading] = useState(false);\n    const file = useRef(null);\n\n    const hasFileInputBeenCanceled = () => {\n        if (!file.current.value.length) setLoading(false);\n        document.body.onfocus = null;\n    }\n\n    const onTriggerFileSelect = useCallback(() => {\n        setLoading(true);\n        document.body.onfocus = hasFileInputBeenCanceled;\n        file.current && file.current.click();\n    }, []);\n\n    const onSelectedFileChanged = useCallback((event) => {\n        event.target.files[0].text().then((text) => {\n            event.target.value = '';\n            onClick(text).then(() => setLoading(false));\n        });\n    }, [onClick]);\n\n    return (\n        <button\n            className=\"RestoreButton\"\n            disabled={isLoading | disabled}\n            onClick={isLoading ? null : onTriggerFileSelect}\n            style={{ \"margin\": \"10px\", \"backgroundColor\": color, \"display\": hidden ? \"none\" : true }}\n        >\n            {isLoading ? 'Loading…' : text}\n            <input\n                type=\"file\"\n                ref={file}\n                onChange={onSelectedFileChanged}\n                accept=\".json\"\n                style={{ \"display\": \"none\" }}\n            />\n        </button>\n    );\n}\n\nexport default RestoreButton","import React, { useState, useCallback } from \"react\";\nimport './index.css';\n\nfunction downloadFile(fileData) {\n    var blob = new Blob([JSON.stringify(fileData, null, 4)], { type: \"application/json;charset=utf-8\" });\n    var url = URL.createObjectURL(blob);\n    var elem = document.createElement(\"a\");\n    elem.href = url;\n    elem.download = \"backup.json\";\n    document.body.appendChild(elem);\n    elem.click();\n    document.body.removeChild(elem);\n}\n\nfunction BackupButton({ text, color, disabled, hidden, onClick }) {\n    const [isLoading, setLoading] = useState(false);\n\n    const onTriggerRunThenSaveFile = useCallback(() => {\n        setLoading(true);\n        onClick().then((fileData) => {\n            if (fileData) downloadFile(fileData);\n            setLoading(false);\n        });\n    }, [onClick]);\n\n    return (\n        <button\n            className=\"BackupButton\"\n            disabled={isLoading | disabled}\n            onClick={isLoading ? null : onTriggerRunThenSaveFile}\n            style={{ \"margin\": \"10px\", \"backgroundColor\": color, \"display\": hidden ? \"none\" : true }}\n        >\n            {isLoading ? 'Loading…' : text}\n        </button>\n    );\n}\n\nexport default BackupButton","import React, { useState } from \"react\";\n\nimport {\n    Accordion,\n    AccordionItem,\n    AccordionItemHeading,\n    AccordionItemButton,\n    AccordionItemPanel,\n} from 'react-accessible-accordion';\nimport ReactMarkdown from 'react-markdown'\nimport './index.css';\n\n\nexport default function AppExplanations() {\n    const [expandedItems, setexpandedItems] = useState([]);\n\n    // In case the user expands a node that is barely visible, we scroll the page to display it fully\n    function handleExpand(update) {\n        if (update.length > expandedItems.length) {\n            const newExpandedItemUUID = update[update.length - 1];\n            const itemButtonBottom = document.getElementById(`accordion__panel-${newExpandedItemUUID}`).getBoundingClientRect().bottom;\n            if (itemButtonBottom > window.innerHeight) {\n                window.scrollBy(0, itemButtonBottom - window.innerHeight);\n            }\n        }\n        setexpandedItems(update);\n    }\n\n    // eslint-disable-next-line\n    const whatIsThisWebApp_help = \"This Web App allows you to backup/restore the list of `password nicknames` stored inside the `Passwords app` on your Ledger Nano S/ Nano X.  \\n\\\n    It is useful to have such a backup when you update the Passwords app on your device, or the device firmware, because the list gets erased. Another case where it's practical to have a nickname backup is when you loose your device: Restoring the [24-words recovery phrase](https://www.ledger.com/academy/crypto/what-is-a-recovery-phrase) is necessary but not sufficient to restore your passwords, you need your nickname list as well.\"\n\n    const whatIsTheLedgerPasswordsApp_help = \"Look [here](https://github.com/LedgerHQ/app-passwords/blob/master/README.md) for more information on the device application itself.\";\n\n    // eslint-disable-next-line\n    const howToUseThisWebApp_help = \"* Connect your Nano S/X to your computer and open the `Passwords app`.\\n\\* You can now click on the big `Connect` button, and if it succeeds the `Backup` and `Restore` buttons should replace the previous button. If you have troubles with this step, have a look [here](https://support.ledger.com/hc/en-us/articles/115005165269-Fix-connection-issues). \\n\\* Either click on `Backup` or `Restore` depending on what you want to do:  \\n\\\n    * `Backup` will prompt a screen requesting your approval on your device (`\\\"Transfer metadatas ?\\\"`), then save a backup file. This is your backup. it's not confidential, so for instance you can send it to yourself by e-mail to never loose it.  \\n\\\n    * `Restore` will prompt a file input dialog where you should indicate a previous backup file. A prompt (`\\\"Overwite metadatas ?\\\"`) will then request your approval on your device. Done.\";\n\n    const whichbrowsersAreSupported_help = \"The communication with the device is done through `WebUSB`, which is curently supported only on `Google Chrome` / `Chromium` / `Brave` for `Linux` and `MacOS`. On `Windows`, [Zadig](https://github.com/WICG/webusb/issues/143) is required.\";\n\n    return (\n        <Accordion allowZeroExpanded allowMultipleExpanded onChange={handleExpand}>\n            <AccordionItem>\n                <AccordionItemHeading>\n                    <AccordionItemButton>\n                        What is this Web App ?\n                    </AccordionItemButton>\n                </AccordionItemHeading>\n                <AccordionItemPanel>\n                    <ReactMarkdown className=\"Explanations\" children={whatIsThisWebApp_help}></ReactMarkdown>\n                </AccordionItemPanel>\n            </AccordionItem>\n            <AccordionItem>\n                <AccordionItemHeading>\n                    <AccordionItemButton>\n                        What is the Ledger Passwords application ?\n                    </AccordionItemButton>\n                </AccordionItemHeading>\n                <AccordionItemPanel>\n                    <ReactMarkdown className=\"Explanations\" children={whatIsTheLedgerPasswordsApp_help}></ReactMarkdown>\n                </AccordionItemPanel>\n            </AccordionItem>\n            <AccordionItem>\n                <AccordionItemHeading>\n                    <AccordionItemButton>\n                        How to use this Web App ?\n                    </AccordionItemButton>\n                </AccordionItemHeading>\n                <AccordionItemPanel>\n                    <ReactMarkdown className=\"Explanations\" children={howToUseThisWebApp_help}></ReactMarkdown>\n                </AccordionItemPanel>\n            </AccordionItem>\n            <AccordionItem>\n                <AccordionItemHeading>\n                    <AccordionItemButton>\n                        Which web browsers are supported ?\n                    </AccordionItemButton>\n                </AccordionItemHeading>\n                <AccordionItemPanel>\n                    <ReactMarkdown className=\"Explanations\" children={whichbrowsersAreSupported_help}></ReactMarkdown>\n                </AccordionItemPanel>\n            </AccordionItem>\n        </Accordion>\n    );\n}","import React, { useState } from \"react\";\nimport logo from './logo.svg';\nimport RestoreButton from './components/RestoreButton';\nimport BackupButton from './components/BackupButton';\nimport PasswordsManager from \"./controller/PasswordsManager.js\";\nimport AppExplanations from \"./components/AppExplanations\";\nimport { ToastContainer, toast } from 'react-toastify';\nimport 'react-toastify/dist/ReactToastify.css';\nimport { listen } from \"@ledgerhq/logs\";\nimport packageJson from '../package.json';\nimport './App.css';\n\nlisten(log => { console.log(log) });\n\nfunction App() {\n\n  function ask_device(device_handler, request) {\n    return new Promise(async (resolve) => {\n      let result = null;\n      try {\n        if (!device_handler.connected) {\n          await device_handler.connect();\n          setConnected(true);\n          toast.info(\"Device connected 👌\", { autoClose: false });\n        }\n        if (request) {\n          toast.info(\"Approve action on your device ✨\", { autoClose: false });\n          setBusy(true);\n          result = await request();\n\n          toast.dismiss();\n          toast.success(\"Success 🦄\");\n        }\n      }\n      catch (error) {\n        device_handler.disconnect()\n        setConnected(false);\n        toast.dismiss();\n        toast.error(`${error.toString()} 🙅`);\n      }\n      finally {\n        setBusy(false);\n        resolve(result);\n      }\n    });\n  }\n\n  // const  = new PasswordsManager(true);\n\n  const [isBusy, setBusy] = useState(false);\n  const [isConnected, setConnected] = useState(false);\n  const [passwordsManager] = useState(new PasswordsManager(true));\n\n  return (\n    <div className=\"App\">\n      <ToastContainer hideProgressBar={true} />\n      <div className=\"App-banner\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p className=\"App-title\">Passwords Backup</p>\n      </div>\n      <header className=\"App-header\">\n        <div className=\"Commands\">\n          <BackupButton text=\"Backup\" color=\"#41ccb4\" disabled={isBusy} hidden={!isConnected} onClick={() => ask_device(passwordsManager, () => passwordsManager.dump_metadatas())} />\n          <RestoreButton text=\"Restore\" color=\"#FFB86D\" disabled={isBusy} hidden={!isConnected} onClick={(metadatas) => ask_device(passwordsManager, () => passwordsManager.load_metadatas(metadatas))} />\n          <BackupButton text=\"Connect\" color=\"#41ccb4\" disabled={isBusy} hidden={isConnected} onClick={() => ask_device(passwordsManager)} />\n        </div>\n        <AppExplanations></AppExplanations>\n        <div className=\"App-footer\">\n          <p>A modest Web App built at Ledger with React, hosted by Github. v{`${packageJson.version}`}. <a href=\"https://github.com/LedgerHQ/passwords-backup\">PRs welcomed and appreciated ✨</a></p>\n        </div>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);","import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n\nconst GET_APP_INFO_COMMAND = 0x01;\nconst GET_APP_CONFIG_COMMAND = 0x03;\nconst DUMP_METADATAS_COMMAND = 0x04;\nconst LOAD_METADATAS_COMMAND = 0x05;\n\nclass PasswordsManager {\n    constructor() {\n        this.allowedStatuses = [0x9000, 0x6985, 0x6A86, 0x6A87, 0x6D00, 0x6E00, 0xB000];\n        this.connected = false;\n        this.busy = false;\n        this.transport = null;\n    }\n\n    async connect() {\n        if (!this.connected) {\n            if (!this.transport) this.transport = await TransportWebUSB.create();\n            try {\n                const [appName, version] = await this.getAppInfo();\n                if (appName.toString() !== \"Passwords\") throw new Error(\"The Passwords app is not opened on the device\");\n                this.version = version;\n                let appConfig = await this.getAppConfig();\n                this.storage_size = appConfig[\"storage_size\"];\n                this.connected = true;\n            }\n            catch (error) {\n                await this.transport.close();\n                this.disconnect();\n                throw error;\n            }\n        }\n    }\n\n    isSuccess(result) {\n        return result.length >= 2 && result.readUInt16BE(result.length - 2) === 0x9000;\n    }\n\n    disconnect() {\n        this.connected = false;\n        this.transport = null;\n    }\n\n    mapProtocolError(result) {\n        if (result.length < 2) throw new Error(\"Response length is too small\");\n\n        var errors = {\n            0x6985: \"Action cancelled\",\n            0x6A86: \"SW_WRONG_P1P2\",\n            0x6A87: \"SW_WRONG_DATA_LENGTH\",\n            0x6D00: \"SW_INS_NOT_SUPPORTED\",\n            0x6E00: \"SW_CLA_NOT_SUPPORTED\",\n            0xB000: \"SW_APPNAME_TOO_LONG\",\n            0x6F10: \"SW_METADATAS_PARSING_ERROR\"\n        }\n\n        let error = result.readUInt16BE(result.length - 2);\n        if (error in errors) {\n            throw new Error(errors[error]);\n        }\n    }\n\n    _lock() {\n        if (this.busy) throw new Error(\"Device is busy\");\n        this.busy = true;\n    }\n\n    _unlock() {\n        this.busy = false;\n    }\n\n    _toBytes(json_metadatas) {\n        let metadatas = Buffer.alloc(this.storage_size);\n        let parsed_metadatas = JSON.parse(json_metadatas)[\"parsed\"];\n        let offset = 0;\n        parsed_metadatas.forEach(element => {\n            let nickname = element[\"nickname\"];\n            let charsets = element[\"charsets\"];\n            if (nickname.length > 19) throw new Error(`Nickname too long (19 max): ${nickname} has length ${nickname.length}`);\n            if (offset + 3 + nickname.length >= this.storage_size) throw new Error(`Not enough memory on this device to restore this backup`);\n            metadatas[offset++] = nickname.length + 1;\n            metadatas[offset++] = 0x00;\n            metadatas[offset++] = charsets;\n            metadatas.write(nickname, offset);\n            offset += nickname.length;\n        });\n        // mark free space at the end of the buffer\n        metadatas[offset++] = 0x00;\n        metadatas[offset++] = 0x00;\n        return metadatas\n    }\n\n    _toJSON(metadatas) {\n        let metadatas_list = [];\n        let erased_list = [];\n        let offset = 0;\n        let corruptions = [];\n        while (true) {\n            let len = metadatas[offset];\n            if (len === 0) break;\n            let erased = metadatas[offset + 1] === 0xFF ? true : false;\n            let charsets = metadatas[offset + 2];\n            if (len > 19 + 1) corruptions += [offset, `nickname too long ${len}, max is 19`]\n            if (!erased) {\n                metadatas_list.push({\n                    \"nickname\": metadatas.slice(offset + 3, offset + 2 + len).toString(),\n                    \"charsets\": charsets\n                });\n            }\n            else {\n                erased_list.push({\n                    \"nickname\": metadatas.slice(offset + 3, offset + 2 + len).toString(),\n                    \"charsets\": charsets\n                });\n            }\n            offset += len + 2;\n        }\n        return {\n            \"parsed\": metadatas_list,\n            \"nicknames_erased_but_still_stored\": erased_list,\n            \"corruptions_encountered\": corruptions,\n            \"raw_metadatas\": metadatas.toString(\"hex\")\n        };\n    }\n\n    async _load_metadatas_chunk(chunk, is_last) {\n        let result = await this.transport.send(0xE0, LOAD_METADATAS_COMMAND, is_last ? 0xFF : 0x00, 0x00, Buffer.from(chunk), this.allowedStatuses);\n        if (!this.isSuccess(result)) this.mapProtocolError(result);\n        return result;\n    }\n    async getAppInfo() {\n        this._lock();\n        try {\n            let result = await this.transport.send(0xB0, GET_APP_INFO_COMMAND, 0x00, 0x00, Buffer(0), this.allowedStatuses);\n            if (!this.isSuccess(result)) this.mapProtocolError(result);\n\n            result = result.slice(0, result.length - 2);\n            let app_name, app_version;\n            try {\n                let offset = 1;\n                let app_name_length = result[offset++];\n                app_name = result.slice(offset, offset + app_name_length).toString();\n                offset += app_name_length;\n                let app_version_length = result[offset++];\n                app_version = result.slice(offset, offset + app_version_length).toString();\n                return [app_name, app_version];\n            }\n            catch (error) {\n                throw new Error(`Unexpected result from device, parsing error: ${error}`);\n            }\n        }\n        finally {\n            this._unlock();\n        }\n    }\n\n    async getAppConfig() {\n        this._lock();\n        try {\n            let result = await this.transport.send(0xE0, GET_APP_CONFIG_COMMAND, 0x00, 0x00, Buffer(0), this.allowedStatuses);\n            if (!this.isSuccess(result)) this.mapProtocolError(result);\n            result = result.slice(0, result.length - 2);\n            if (result.length !== 6) throw new Error(`Can't parse app config of length ${result.length}`);\n\n            let storage_size = result.readUInt32BE(0, 4);\n            let keyboard_type = result[4];\n            let press_enter_after_typing = result[5];\n            return { storage_size, keyboard_type, press_enter_after_typing };\n        }\n        finally {\n            this._unlock();\n        }\n    }\n\n\n    async dump_metadatas() {\n        this._lock();\n        try {\n            let metadatas = Buffer.alloc(0)\n            while (metadatas.length < this.storage_size) {\n                let result = await this.transport.send(0xE0, DUMP_METADATAS_COMMAND, 0x00, 0x00, Buffer(0), this.allowedStatuses);\n                if (!this.isSuccess(result)) this.mapProtocolError(result);\n                metadatas = Buffer.concat([metadatas, Buffer.from(result.slice(1, -2))]);\n                if (result[0] === 0xFF && metadatas.length < this.storage_size) {\n                    throw new Error(`${this.storage_size} bytes requested but only ${metadatas.length} bytes available`);\n                }\n            }\n            return this._toJSON(metadatas);\n        }\n        finally {\n            this._unlock();\n        }\n    }\n\n    async load_metadatas(JSON_metadatas) {\n        this._lock();\n        try {\n            let metadatas = this._toBytes(JSON_metadatas);\n            if (metadatas.length === 0) {\n                throw new Error(\"No data to load\");\n            }\n            for (let i = 0; i < metadatas.length; i += 0xFF) {\n                let chunk = metadatas.slice(i, i + 0xFF);\n                await this._load_metadatas_chunk(chunk, i + chunk.length === metadatas.length ? true : false)\n            }\n        }\n        finally {\n            this._unlock();\n        }\n    }\n\n}\n\nexport default PasswordsManager"],"sourceRoot":""}